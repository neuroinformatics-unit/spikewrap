from __future__ import annotations

from typing import Callable, Literal

import numpy as np
import spikeinterface.full as si
from spikeinterface import BaseRecording

from spikewrap.utils import _utils


def _preprocess_recording(
    preprocess_data: dict[str, list],
    pp_steps: dict,
) -> dict:
    """
    Fill the Preprocessed._data dict with preprocessed
    SpikeInterface recording objects according to pp_steps.
    For each preprocessing step, the key will be a concatenation
    of all preprocessing steps that were performed.
    e.g. "0-raw", "0-raw_1-phase_shift_2-bandpass_filter"

    Parameters
    ----------
    preprocess_data
        Dictionary to store the newly created recording objects, updated in-place.
    pp_steps
        "preprocessing" entry of a "configs" dictionary. Formatted as
        {step_num_str : [preprocessing_func_name, {pp_func_args}]
    """
    pp_funcs = _get_pp_funcs()

    checked_pp_steps, pp_step_names = _check_and_sort_pp_steps(pp_steps, pp_funcs)

    for step_num, pp_info in checked_pp_steps.items():

        pp_name, pp_options = pp_info

        last_pp_step_output, _ = _utils._get_dict_value_from_step_num(
            preprocess_data, step_num=str(int(step_num) - 1)
        )

        preprocessed_recording = pp_funcs[pp_name](last_pp_step_output, **pp_options)

        new_name = f"{step_num}-" + "-".join(["raw"] + pp_step_names[: int(step_num)])

        preprocess_data[new_name] = preprocessed_recording

    return preprocess_data


# Helpers for preprocessing steps dictionary -------------------------------------------


def _check_and_sort_pp_steps(pp_steps: dict, pp_funcs: dict) -> tuple[dict, list[str]]:
    """
    Sort the preprocessing steps dictionary by order to be run
    (based on the keys) and check the dictionary is valid.

    Parameters
    ----------
    pp_steps dict
        "preprocessing" entry of a "configs" dictionary. Formatted as
        {step_num_str : [preprocessing_func_name, {pp_func_args}]
    pp_funcs
        A dictionary linking preprocessing step names to the underlying
        SpikeInterface preprocessing functions.

    Returns
    -------
    pp_steps
        The checked pp_steps dictionary.
    pp_step_names
        List of ordered preprocessing step names (e.g. "bandpass_filter").
    """
    _validate_pp_steps(pp_steps)
    pp_step_names = [item[0] for item in pp_steps.values()]

    # Check the preprocessing function names are valid and print steps used
    canonical_step_names = list(pp_funcs.keys())

    for user_passed_name in pp_step_names:
        assert (
            user_passed_name in canonical_step_names
        ), f"{user_passed_name} not in allowed names: ({canonical_step_names}"

    return pp_steps, pp_step_names


def _validate_pp_steps(pp_steps: dict) -> None:
    """
    Ensure the pp_steps dict step numbers start 1 at,
    and increase by 1 for each subsequent step.

    Parameters
    ----------
    pp_steps
        "preprocessing" entry of a "configs" dictionary. Formatted as
        {step_num_str : [preprocessing_func_name, {pp_func_args}]
    """
    assert all(
        key.isdigit() for key in pp_steps.keys()
    ), "pp_steps keys must be integers"

    key_nums = [int(key) for key in pp_steps.keys()]

    assert np.min(key_nums) == 1, "dict keys must start at 1"

    if len(key_nums) > 1:
        diffs = np.diff(key_nums)
        assert np.unique(diffs).size == 1, "all dict keys must increase in steps of 1"
        assert diffs[0] == 1, "all dict keys must increase in steps of 1"


def _get_pp_funcs() -> dict[str, Callable]:
    """
    Returns a dict mapping SpikeInterface preprocessing
    function name to the function object.
    """
    pp_funcs = {
        "phase_shift": si.phase_shift,
        "bandpass_filter": si.bandpass_filter,
        "common_reference": si.common_reference,
        "whiten": si.whiten,
        "remove_bad_channels": remove_bad_channels,
        "interpolate_bad_channels": interpolate_bad_channels,
        "remove_channels": remove_channels,
        "interpolate_channels": interpolate_channels,
    }

    return pp_funcs


# Custom Preprocessors
# ----------------------------------------------------------------------
# NOTE: these are autogenerated on the API docs, must be updated on the 'supported preprocessing' docs.
# These should be merged into SpikeInterface in future wherever possible
# TODO: suggest feature on SI side to sub-select by label,
# await https://github.com/SpikeInterface/spikeinterface/pull/3685


def remove_bad_channels(
    recording: BaseRecording,
    labels_to_remove: Literal["all"] | str | list[str] = "all",
    detect_bad_channel_kwargs: dict | None = None,
):
    """
    Detect bad channels on the recording ("dead", "noise" or "out")
    and remove them. Uses on SpikeInterface's ``detect_bad_channels``
    and `remove_channels`` functions.

    Parameters
    ----------

    recording
        The spikeinterface recording object to preprocess
        (not passed via spikewrap config dictionary).
    labels_to_remove
        A list of labels, channels that are categorised with this
        label will be removed. Can be some combination
        of "dead", "noise" or "out". "all" will remove channels
        with any of these labels.
    detect_bad_channel_kwargs
        dictionary of kwargs passed to SpikeInterface's
        ``detect_bad_channels`` function.
    """
    ids_to_remove = _get_bad_channel_ids(
        recording, labels_to_remove, detect_bad_channel_kwargs
    )

    return remove_channels(recording, ids_to_remove)


def interpolate_bad_channels(
    recording: BaseRecording,
    labels_to_remove: Literal["all"] | str | list[str] = "all",
    detect_bad_channel_kwargs: dict | None = None,
    interpolate_bad_channel_kwargs: dict | None = None,
):
    """
    Detect bad channels on the recording ("dead", "noise" or "out")
    and interpolate them. Uses on SpikeInterface's
    ``detect_bad_channels`` and `interpolate_bad_channels`` functions.

    """
    ids_to_interpolate = _get_bad_channel_ids(
        recording, labels_to_remove, detect_bad_channel_kwargs
    )

    if interpolate_bad_channel_kwargs is None:
        interpolate_bad_channel_kwargs = {}

    return interpolate_channels(
        recording, ids_to_interpolate, interpolate_bad_channel_kwargs
    )


def remove_channels(recording: BaseRecording, channel_ids: list[str]) -> BaseRecording:
    """
    Return the recording with channels removed.

    Parameter
    ---------
    recording
        The spikeinterface recording object to preprocess
        (not passed via spikewrap config dictionary).
    channel_ids
        List of channel ids, corresponding channels will be
        removed from the recording.
    """
    return recording.remove_channels(channel_ids)


def interpolate_channels(
    recording: BaseRecording,
    channel_ids: list[str],
    interpolate_bad_channel_kwargs: dict | None = None,
) -> BaseRecording:
    """
    Return the recording with channels interpolated.
    Kriging interpolation used, as implemented in the
    SpikeInterface function ``interpolate_bad_channels``.

    Parameter
    ---------
    recording
        The spikeinterface recording object to preprocess
        (not passed via spikewrap config dictionary).
    channel_ids
        List of channel ids, corresponding channels will be
        interpolated.
    interpolate_bad_channel_kwargs
        dictionary of kwargs passed to SpikeInterface's
        ``interpolate_bad_channels`` function.
    """
    if interpolate_bad_channel_kwargs is None:
        interpolate_bad_channel_kwargs = {}

    return si.interpolate_bad_channels(
        recording, channel_ids, **interpolate_bad_channel_kwargs
    )


def _get_bad_channel_ids(
    recording: BaseRecording,
    labels_to_remove: Literal["all"] | str | list[str] = "all",
    detect_bad_channel_kwargs: dict | None = None,
):
    """
    Returns a list of channel ids corresponding to the
    labels that match ``labels_to_remove``. These are the labels
    returned by SpikeInterface's ``detect_bad_channel`` kwargs
    (returned in a list that maps 1:1 on the channel ids from
    `get_channel_ids`.
    """
    # Detect the bad channels.
    if detect_bad_channel_kwargs is None:
        detect_bad_channel_kwargs = {}

    bad_channel_ids, channel_labels = si.detect_bad_channels(
        recording, **detect_bad_channel_kwargs
    )

    all_dead_labels = ["dead", "noise", "out"]

    if labels_to_remove == "all":
        # By default, SpikeInterface will remove all bad channels
        ids_to_remove = bad_channel_ids
    else:
        if isinstance(labels_to_remove, str):
            labels_to_remove = [labels_to_remove]

        channel_ids = recording.get_channel_ids()

        # Iterate through the labels to match, collecting
        # all corresponding channel ids.
        ids_to_remove = []
        for label in labels_to_remove:

            if label not in all_dead_labels:
                raise ValueError(
                    f"The passed label {label} is not valid, valid labels are: {all_dead_labels}"
                )

            chan_id_by_label = [
                id for (i, id) in enumerate(channel_ids) if channel_labels[i] == label
            ]

            ids_to_remove += chan_id_by_label

    return ids_to_remove
